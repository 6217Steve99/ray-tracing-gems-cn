如Amstutz等人在[1]中讨论的和9.1节中所述，重叠的节点使得以无序BVH遍历的方式进行多重命中光线追踪的问题更加复杂。为保证正确性，或者需要使用较为朴素但可能也非常耗时的方式进行多重命中遍历[5]，或者需要修改BVH的构造和遍历例程，后者不仅会给生产环境引入潜在的大量开发和维护的负担，而且对于与实现无关的光线追踪API来说根本不可能达成。
为了解决这些问题，我们提出两套基于DXR的多重命中遍历实现，每套实现都包含两种算法：朴素的多重命中遍历和节点剔除多重命中BVH遍历[3]。我们对每个算法的第一套实现通过借助DXR任意命中着色器来满足每条光线上的多重命中相交查询。每当一条光线在当前光线区间[tmin, tmax]内与某个几何体相交时就会触发执行DXR任意命中着色器，无论此区间沿光线相对于其他交点的位置如何。对沿光线的交点，这些着色器不遵循任何预定义的执行顺序。如果一个任意命中着色器接受了一个潜在的交点，那么该点的命中距离将成为光线区间的新的最大值，即tmax。我们对每个算法的第二套实现通过使用DXR相交着色器来满足多重命中查询，DXR 相交着色器提供了一种使用底层加速结构的几何体的替代表达。在这种情况下，程序所处理的图元由其与坐标轴对齐的包围盒定义，并且由一个用户定义的相交着色器在光线与包围盒相交的时候重新计算图元上的交点。相交着色器定义了用于描述交点的属性，包括命中距离，这些属性会被传递给后续的着色器。一般来说，DXR相交着色器的效率低于内置的光线/三角形相交例程，但是提供了更大的灵活性。我们利用这些着色器实现了三角形图元的朴素的和节点剔除多重命中光线遍历，作为DXR任意命中着色器之外的另一种实现。
在这些实现中，每个着色器都假定存在用于存储多重命中结果的两个缓冲区：一个二维 (width x height)缓冲区用于存储每条光线的命中计数和一个三维 (width x height x (Nquery + 1))缓冲区用于存储命中记录，每个记录包含命中点的相交距离(t-value)，表面漫反射颜色和Ng ⋅ V 来支持简单表面着色操作。使用任意命中着色器的实现使用了一个用户定义的光线有效负载结构来跟踪当前的命中数量并且需要设置几何标记D3D12_RAYTRACING_GEOMETRY_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION以禁止任意命中着色器的多重调用。相应的光线生成着色器需设置光线标志RAY_FLAG_FORCE_NON_OPAQUE以将所有光线/图元交点视为非不透明的。而使用相交着色器的实现需要存储三角形顶点、面和材质数据的缓冲区，当使用内置的三角形图元时这些属性通常由DXR管理。
所有的着色器都依赖于一些工具函数以实现着色器侧的缓冲区管理、可视化色彩映射等等。同样，每个着色器都假定有一些值用来控制最终渲染结果，包括Nquery、背景颜色、和一些能够影响我们的示例应用所支持的可视化模式的颜色映射参数。其他DXR着色器的状态和参数，例如存储渲染结果的二维输出缓冲区，统一由Falcor [2]管理，Falcor是作为我们应用基础的实时渲染框架。为清晰起见并保持本文叙述的重点，下面的实现要点中省略了这些元素。
我们的示例光线追踪应用利用了建立在Falcor之上的Chris Wyman的dxrTutors.Code项目[8]以管理DXR状态。dxrTutors.Code项目提供了高度抽象的CPU侧C++ DXR API，旨在帮助程序员使DXR应用程序快速跑通并且能够进行简单的实验。虽然从源代码构建我们的多重命中光线追踪应用需要这些依赖，但多重命中DXR着色器本身可以非常直接地适用于提供了类似DXR抽象的其他框架。我们将在本节的其余部分重点介绍这些实现，并在9.3节中探讨其性能。